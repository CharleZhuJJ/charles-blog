import{_ as o}from"./chunks/ArticleMetadata.4c626a83.js";import{_ as n,D as i,o as s,c as p,G as d,B as c,z as h,a as u,R as _,A as m,C as H}from"./chunks/framework.ef995079.js";const x=JSON.parse('{"title":"哈希（Hash）","description":"","frontmatter":{},"headers":[],"relativePath":"md/Java/javaUnderlayer/Hash.md","filePath":"md/Java/javaUnderlayer/Hash.md","lastUpdated":1688441607000}'),f={name:"md/Java/javaUnderlayer/Hash.md"},y=h("h1",{id:"哈希-hash",tabindex:"-1"},[u("哈希（Hash） "),h("a",{class:"header-anchor",href:"#哈希-hash","aria-label":'Permalink to "哈希（Hash）"'},"​")],-1),S=_('<p>  哈希表的出现是为了解决链表访问不快速的弱点</p><p>  哈希表中有一个哈希函数(散列函数)。即构建一个确定的映射，它能把关键字映射到一个唯一的存储位置。这种映射应该是我们可以进行计算的。</p><p>  已知关键字，我们应该能算出其地址；反之，已知地址，我们可以检索到对应的关键字。一旦建立起这种关系，那么给定关键字，我就能直接利用这个映射(即所谓的哈希函数)直接算出其地址并寻址。这可大大缩减确定关键字存储位置所花的时间。</p><h2 id="hashset-和-hashmap" tabindex="-1">HashSet 和 HashMap <a class="header-anchor" href="#hashset-和-hashmap" aria-label="Permalink to &quot;HashSet 和 HashMap&quot;">​</a></h2><p>  HashSet是通过HashMap来实现的，HashMap的输入参数有Key、Value两个组成，在实现HashSet的时候，保持HashMap的Value为常量，相当于在HashMap中只对Key对象进行处理。</p><p>  HashMap的底层是一个数组结构，数组中的每一项对应了一个链表，这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。</p><p>  HashSet实现了Set接口，其内部不允许出现重复的值，如果我们将一个对象存入HashSet，必须重写equals()和hashCode()方法，这样才能确保集合中不存在同一个元素。HashSet的内部是无序的，因此不能使用 hashset.get(index) 来获取元素。</p><p>  HashMap实现了Map接口，其内容是键值对的映射（key-&gt;value），不允许出现相同的键（key）。在查询的时候会根据给出的键来查询对应的值。</p><h3 id="hashmap存储对象的过程" tabindex="-1">HashMap存储对象的过程 <a class="header-anchor" href="#hashmap存储对象的过程" aria-label="Permalink to &quot;HashMap存储对象的过程&quot;">​</a></h3><ul><li>对HashMap的Key调用hashCode()方法，返回int值，即对应的hashCode；</li><li>把此hashCode作为哈希表的索引，查找哈希表相应位置，若当前位置内容为NULL，则把HashMap的Key、Value包装成Entry数组，放入当前位置；</li><li>若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；</li><li>若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；</li></ul><h3 id="hashset存储对象的过程" tabindex="-1">HashSet存储对象的过程 <a class="header-anchor" href="#hashset存储对象的过程" aria-label="Permalink to &quot;HashSet存储对象的过程&quot;">​</a></h3><ul><li>往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，</li><li>然后通过元素的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置，存储时会出现两种情况： <ul><li>情况1：如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。</li><li>情况2：如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素允许添加。</li></ul></li></ul><h2 id="哈希表的扩容" tabindex="-1">哈希表的扩容 <a class="header-anchor" href="#哈希表的扩容" aria-label="Permalink to &quot;哈希表的扩容&quot;">​</a></h2><p>  哈希表容量的大小在一开始是不确定的。如果哈希表存储的元素太多（如超过容量的30%），我们应该将哈希表容量扩大一倍，并将所有的哈希值重新安排。</p>',14);function M(a,q,C,V,k,b){const l=o,r=i("ClientOnly");return s(),p("div",null,[y,d(r,null,{default:c(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(s(),m(l,{key:0,article:a.$frontmatter},null,8,["article"])):H("",!0)]}),_:1}),S])}const N=n(f,[["render",M]]);export{x as __pageData,N as default};
