import{_ as n}from"./chunks/ArticleMetadata.8b6b367a.js";import{_ as s,H as c,o as t,c as d,J as h,E as P,C as i,a as p,V as u,D as _,G as m}from"./chunks/framework.981adca9.js";const I="/charles-blog/assets/LoadBalanceTwo.c60b1f6f.png",b="/charles-blog/assets/LoadBalanceIp.3a207656.png",f="/charles-blog/assets/LoadBalanceNat.a0d3f10e.png",C="/charles-blog/assets/LoadBalanceFour.3ad12b5b.png",g="/charles-blog/assets/LoadBalanceSeven.d183473f.png",M=JSON.parse('{"title":"负载均衡","description":"","frontmatter":{"title":"负载均衡","author":"Charles Chu","date":"2022/01/11","isOriginal":true},"headers":[],"relativePath":"md/network/LoadBalance.md","filePath":"md/network/LoadBalance.md","lastUpdated":1692503304000}'),B={name:"md/network/LoadBalance.md"},A=i("h1",{id:"负载均衡",tabindex:"-1"},[p("负载均衡 "),i("a",{class:"header-anchor",href:"#负载均衡","aria-label":'Permalink to "负载均衡"'},"​")],-1),L=u('<h2 id="二层负载均衡" tabindex="-1">二层负载均衡 <a class="header-anchor" href="#二层负载均衡" aria-label="Permalink to &quot;二层负载均衡&quot;">​</a></h2><ul><li>工作在数据链路层的负载均衡称之为二层负载均衡(又称为数据链路层负载均衡)，通过在通信协议的数据链路层修改mac地址进行负载均衡。</li><li>二层负载均衡是基于数据链路层的负载均衡，即让负载均衡服务器和业务服务器绑定同一个虚拟IP（即VIP），客户端直接通过这个VIP进行请求集群。集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡。</li><li>数据链路层负载均衡所做的工作，是修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（真实服务器）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。 <img src="'+I+'" alt="LoadBalanceTwo"></li><li>在上图中，用户的请求首先到达ip为192.168.1.1的二层负载均衡器，然后二层负载均衡器通过采取一定的策略，选中了mac地址为71:63:52:A3:CA，然后将流量转发至该服务实例。</li><li>需要注意的是,上述只有请求经过负载均衡器，而服务的响应无须从负载均衡器原路返回的工作模式，整个请求、转发、响应的链路形成一个“三角关系”，所以这种负载均衡模式也常被很形象地称为“三角传输模式”，也有叫“单臂模式”或者“直接路由”。</li><li>二层负载均衡器直接改写目标 MAC 地址的工作原理决定了它与真实的服务器的通信必须是二层可达的，通俗地说就是必须位于同一个子网当中，无法跨 VLAN。优势（效率高）和劣势（不能跨子网）共同决定了数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</li></ul><h2 id="三层负载均衡" tabindex="-1">三层负载均衡 <a class="header-anchor" href="#三层负载均衡" aria-label="Permalink to &quot;三层负载均衡&quot;">​</a></h2><ul><li>三层负载均衡是基于网络层的负载均衡，因此又叫网络层负载均衡。通俗的说就是按照不同机器不同IP地址进行转发请求到不同的机器上。</li><li>三层负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过IP将请求转发至不同的真实服务器。</li><li>在IP分组的数据报header中有 源IP 和 目标IP。源IP和目标IP代表分组交换中数据是从哪台机器到哪台机器的，那么，我们可以采用跟修改二层负载均衡中MAC地址的方式一样，直接修改目标IP，以达到数据转发的目的。</li></ul><h3 id="修改目标ip的方式" tabindex="-1">修改目标IP的方式 <a class="header-anchor" href="#修改目标ip的方式" aria-label="Permalink to &quot;修改目标IP的方式&quot;">​</a></h3><h4 id="原有数据包保持不变" tabindex="-1">原有数据包保持不变 <a class="header-anchor" href="#原有数据包保持不变" aria-label="Permalink to &quot;原有数据包保持不变&quot;">​</a></h4><p>  原有的数据包保持不变，生成一个新的数据包，原数据包的Header和Payload作为新数据包的Payload，在这个新数据包的 Headers 中写入真实服务器的 IP 作为目标地址，然后把它发送出去。</p><ul><li>真实服务器收到数据包后，必须在接收入口处设计一个针对性的拆包机制，把由负载均衡器自动添加的那层 Headers 扔掉，还原出原来的数据包来进行使用。这样，真实服务器就同样拿到了一个原本不是发给它（目标 IP 不是它）的数据包，达到了流量转发的目的。这种数据传输方式叫做 IP隧道 传输。</li><li>尽管因为要封装新的数据包，IP 隧道的转发模式比起直接路由模式效率会有所下降，但由于并没有修改原有数据包中的任何信息，所以 IP 隧道的转发模式仍然具备三角传输的特性，即负载均衡器转发来的请求，可以由真实服务器去直接应答，无须在经过均衡器原路返回。而且由于 IP 隧道工作在网络层，所以可以跨越 VLAN，因此摆脱了直接路由模式中网络侧的约束。</li></ul><p>  此模式从请求到响应如下图所示： <img src="'+b+'" alt="LoadBalanceIp"></p><h4 id="改变目标数据包" tabindex="-1">改变目标数据包 <a class="header-anchor" href="#改变目标数据包" aria-label="Permalink to &quot;改变目标数据包&quot;">​</a></h4><p>  直接把数据包 Headers 中的目标地址改为真实服务器地址，修改后原本由用户发给均衡器的数据包，也会被三层交换机转发送到真实服务器的网卡上，而且因为没有经过 IP 隧道的额外包装，也就无须再拆包了。</p><ul><li>因为这种模式是通过修改目标 IP 地址才到达真实服务器的，如果真实服务器直接将应答包返回客户端的话，这个应答数据包的源 IP 是真实服务器的 IP，也即均衡器修改以后的 IP 地址，客户端不可能认识该 IP，自然就无法再正常处理这个应答了。因此，只能让应答流量继续回到负载均衡，由负载均衡把应答包的源 IP 改回自己的 IP，再发给客户端，这样才能保证客户端与真实服务器之间的正常通信。</li><li>这种修改目标IP的方式叫NAT模式，这种通过修改目标IP的方式达到负载均衡目的的方式叫做NAT负载均衡。</li></ul><p>  如下图所示： <img src="'+f+'" alt="LoadBalanceNat"></p><h2 id="四层负载均衡" tabindex="-1">四层负载均衡 <a class="header-anchor" href="#四层负载均衡" aria-label="Permalink to &quot;四层负载均衡&quot;">​</a></h2><ul><li>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</li><li>由于四层负载均衡是作用在传输层，因此，我们就以常见的TCP进行举例。</li><li>负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。 四层负载均衡主要是基于tcp协议报文，可以做任何基于tcp/ip协议的软件的负载均衡，比如Haproxy、LVS等。 <img src="'+C+'" alt="LoadBalanceFour"></li></ul><h2 id="七层负载均衡" tabindex="-1">七层负载均衡 <a class="header-anchor" href="#七层负载均衡" aria-label="Permalink to &quot;七层负载均衡&quot;">​</a></h2><ul><li>七层负载均衡也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</li><li>应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。</li><li>以TCP为例。负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</li><li>七层负载均衡基本都是基于http协议的，适用于web服务器的负载均衡，比如Nginx等。 <img src="'+g+'" alt="LoadBalanceSeven"></li></ul>',17);function k(a,N,T,q,V,x){const o=n,r=c("ClientOnly");return t(),d("div",null,[A,h(r,null,{default:P(()=>{var e,l;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((l=a.$frontmatter)==null?void 0:l.showArticleMetadata)??!0)?(t(),_(o,{key:0,article:a.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),L])}const $=s(B,[["render",k]]);export{M as __pageData,$ as default};
