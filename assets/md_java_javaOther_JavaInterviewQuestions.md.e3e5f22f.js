import{_ as y}from"./chunks/ArticleMetadata.8b6b367a.js";import{_ as A,H as l,o as p,c as D,C as t,a as o,J as e,E as u,V as C,D as h,G as d}from"./chunks/framework.981adca9.js";const B="/charles-blog/assets/Collection.70e01d0a.png",E="/charles-blog/assets/Map.512e2014.png",F="/charles-blog/assets/AsymmetricEncryption.950c6fef.png",m="/charles-blog/assets/Middleman.fac6231d.png",T=JSON.parse('{"title":"Java面试题","description":"","frontmatter":{"title":"Java面试题","author":"Charles Chu","date":"2023/02/26","isOriginal":true},"headers":[],"relativePath":"md/java/javaOther/JavaInterviewQuestions.md","filePath":"md/java/javaOther/JavaInterviewQuestions.md","lastUpdated":1701505504000}'),b={name:"md/java/javaOther/JavaInterviewQuestions.md"},g={id:"java面试题",tabindex:"-1"},q=t("a",{class:"header-anchor",href:"#java面试题","aria-label":'Permalink to "Java面试题 <Badge text="持续更新" type="warning" />"'},"​",-1),S=C(`<h2 id="java跨平台原理-字节码文件、虚拟机" tabindex="-1">Java跨平台原理（字节码文件、虚拟机） <a class="header-anchor" href="#java跨平台原理-字节码文件、虚拟机" aria-label="Permalink to &quot;Java跨平台原理（字节码文件、虚拟机）&quot;">​</a></h2><p>  C/C++语言都直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。</p><p>  Java源程序（.java）要先编译成与平台无关的字节码文件(.class)，然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。</p><p>  字节码文件不面向任何具体平台，只面向虚拟机。</p><ul><li>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。</li><li>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。</li><li>Java的跨平台原理决定了其性能没有C/C++高</li></ul><h2 id="什么是jvm-什么是jdk-什么是jre" tabindex="-1">什么是JVM？什么是JDK？ 什么是JRE？ <a class="header-anchor" href="#什么是jvm-什么是jdk-什么是jre" aria-label="Permalink to &quot;什么是JVM？什么是JDK？ 什么是JRE？&quot;">​</a></h2><h3 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h3><ul><li>JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</li><li>JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。</li><li>JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。</li><li>JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。</li><li>JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</li></ul><h3 id="jre" tabindex="-1">JRE <a class="header-anchor" href="#jre" aria-label="Permalink to &quot;JRE&quot;">​</a></h3><ul><li>JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。</li><li>在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。</li><li>所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。</li><li>JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。</li><li>JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</li></ul><h3 id="jdk" tabindex="-1">JDK <a class="header-anchor" href="#jdk" aria-label="Permalink to &quot;JDK&quot;">​</a></h3><ul><li>JDK是java development kit（java开发工具包）的缩写。</li><li>每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。</li><li>在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。</li></ul><h3 id="jdk-jre-jvm三者关系概括如下" tabindex="-1">JDK,JRE,JVM三者关系概括如下 <a class="header-anchor" href="#jdk-jre-jvm三者关系概括如下" aria-label="Permalink to &quot;JDK,JRE,JVM三者关系概括如下&quot;">​</a></h3><ul><li>jdk是JAVA程序开发时用的开发工具包，其内部也有Java运行环境JRE。</li><li>JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。</li><li>JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</li></ul><h2 id="面向过程和面向对象的区别" tabindex="-1">面向过程和面向对象的区别 <a class="header-anchor" href="#面向过程和面向对象的区别" aria-label="Permalink to &quot;面向过程和面向对象的区别&quot;">​</a></h2><p>  两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p><p>  面向过程是蛋炒饭，面向对象是盖浇饭。盖浇饭的好处就是“菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是“可维护性”比较好，“饭” 和“菜”的耦合度比较低。蛋炒饭就不行了, 如果不满意就要丢掉重做;</p><ul><li>区别 <ul><li>编程思路不同： 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li><li>封装性：都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</li><li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</li></ul></li></ul><h2 id="继承条件下构造方法的执行过程" tabindex="-1">继承条件下构造方法的执行过程 <a class="header-anchor" href="#继承条件下构造方法的执行过程" aria-label="Permalink to &quot;继承条件下构造方法的执行过程&quot;">​</a></h2><ul><li>情况1：如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法。在这种情况下，写不写“super();”语句，效果是一样的。</li><li>情况2：如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法。</li><li>情况3：如果子类的构造方法中通过this显式调用自身的其他构造方法，在相应构造方法中应用以上两条规则。</li><li>特别注意的是，如果存在多级继承关系，在创建一个子类对象时，以上规则会多次向更高一级父类应用，一直到执行顶级父类Object类的无参构造方法为止。</li></ul><h2 id="integer与int的区别" tabindex="-1">Integer与int的区别 <a class="header-anchor" href="#integer与int的区别" aria-label="Permalink to &quot;Integer与int的区别&quot;">​</a></h2><p>  int是java提供的8种原始数据类型之一，Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。</p><p>  int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p><p>  在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</p><p>  另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量</p><h2 id="构造器是否可以重写" tabindex="-1">构造器是否可以重写 <a class="header-anchor" href="#构造器是否可以重写" aria-label="Permalink to &quot;构造器是否可以重写&quot;">​</a></h2><p>  Constructor 不能被 override（重写），但是可以 overload（重载），所以你可以看到⼀个类中有多个构造函数的情况。</p><h2 id="和-equals-的区别" tabindex="-1">== 和 equals 的区别 <a class="header-anchor" href="#和-equals-的区别" aria-label="Permalink to &quot;== 和 equals 的区别&quot;">​</a></h2><p>  == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)。</p><p>  equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><h2 id="为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1">为什么重写 equals 时必须重写 hashCode 方法： <a class="header-anchor" href="#为什么重写-equals-时必须重写-hashcode-方法" aria-label="Permalink to &quot;为什么重写 equals 时必须重写 hashCode 方法：&quot;">​</a></h2><p>  如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。两个对象有相同的 hashcode 值，它们也不一定是相等的。因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</p><h2 id="为什么要有-hashcode-以-hashset-如何检查重复-为例子来说明为什么要有-hashcode" tabindex="-1">为什么要有 hashcode：以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： <a class="header-anchor" href="#为什么要有-hashcode-以-hashset-如何检查重复-为例子来说明为什么要有-hashcode" aria-label="Permalink to &quot;为什么要有 hashcode：以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：&quot;">​</a></h2><p>  当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h2 id="hashmap-使用-string-作为-key-有什么好处" tabindex="-1">HashMap 使用 String 作为 key 有什么好处 <a class="header-anchor" href="#hashmap-使用-string-作为-key-有什么好处" aria-label="Permalink to &quot;HashMap 使用 String 作为 key 有什么好处&quot;">​</a></h2><p>  HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p><h2 id="java子类继承父类后new子类对象的过程" tabindex="-1">JAVA子类继承父类后new子类对象的过程 <a class="header-anchor" href="#java子类继承父类后new子类对象的过程" aria-label="Permalink to &quot;JAVA子类继承父类后new子类对象的过程&quot;">​</a></h2><ol><li>父类静态变量</li><li>父类静态代码块</li><li>子类静态变量</li><li>子类静态代码块</li><li>父类非静态变量</li><li>父类非静态代码块</li><li>父类匿名内部类</li><li>父类静态方法</li><li>子类非静态变量</li><li>子类非静态代码块</li><li>子类匿名内部类</li><li>子类构造方法。</li></ol><p>总结：先父后子，先静态后非静态</p><ul><li>父类静态-子类静态（静态代码块只执行一次）</li><li>父类非静态-父类构造（子类无参构造写不写super(),默认都走父类无参构造，子类构造写super(有参)，走父类的有参构造）</li><li>子类非静态-子类构造 (创建子类对象时无参走无参构造方法，有参走有参构造方法)</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">Father</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;">{</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的静态代码块{}执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    {</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的非静态代码块{}执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Father</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的无参构造structure 执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Father</span><span style="color:#ADBAC7;">(String </span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">,Integer </span><span style="color:#F69D50;">age</span><span style="color:#ADBAC7;">){</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#768390;">//super(); 默认执行父类的无参构造</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.age </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的有参构造structure 执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Read</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的静态Read方法执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">tour</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;父类的非静态tour方法执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> String</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> Integer</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> String </span><span style="color:#DCBDFB;">getName</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">setName</span><span style="color:#ADBAC7;">(String </span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> Integer </span><span style="color:#DCBDFB;">getAge</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">setAge</span><span style="color:#ADBAC7;">(Integer </span><span style="color:#F69D50;">age</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.age </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">Son</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">extends</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">Father</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;">{</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的静态代码块{}执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    {</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的非静态代码块{}执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Son</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#768390;">//super(); 默认执行Father的无参构造</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的无参构造structure 执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Son</span><span style="color:#ADBAC7;">(String </span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">, Integer </span><span style="color:#F69D50;">age</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#768390;">//super(); 默认执行Father的无参构造</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">super</span><span style="color:#ADBAC7;">(name,age); </span><span style="color:#768390;">//执行Father的有参构造</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.age </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的有参构造structure 执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Read</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的静态Read方法执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    @</span><span style="color:#F47067;">Override</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">tour</span><span style="color:#ADBAC7;">(){</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;子类的非静态tour方法执行了。。。&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> String</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> Integer</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> String </span><span style="color:#DCBDFB;">getName</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">setName</span><span style="color:#ADBAC7;">(String </span><span style="color:#F69D50;">name</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.name </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> name;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> Integer </span><span style="color:#DCBDFB;">getAge</span><span style="color:#ADBAC7;">() {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">setAge</span><span style="color:#ADBAC7;">(Integer </span><span style="color:#F69D50;">age</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">        </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.age </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> age;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">MainTest</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">main</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">String</span><span style="color:#ADBAC7;">[] </span><span style="color:#F69D50;">args</span><span style="color:#ADBAC7;">) {      </span></span>
<span class="line"><span style="color:#ADBAC7;">        Son</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">son</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Son</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">        System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;======================&quot;</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">        Son</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">son1</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Son</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;谭谭&quot;</span><span style="color:#ADBAC7;">,</span><span style="color:#6CB6FF;">32</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">/*</span></span>
<span class="line"><span style="color:#768390;">输出结果：</span></span>
<span class="line"><span style="color:#768390;">父类的静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">子类的静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">父类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">父类的无参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">子类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">子类的无参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">======================</span></span>
<span class="line"><span style="color:#768390;">父类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">父类的有参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">子类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">子类的有参构造structure 执行了。。。</span></span>
<span class="line"><span style="color:#768390;">*/</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Father</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的静态代码块{}执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的非静态代码块{}执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Father</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的无参构造structure 执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Father</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">,Integer </span><span style="color:#E36209;">age</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//super(); 默认执行父类的无参构造</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的有参构造structure 执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Read</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的静态Read方法执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tour</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;父类的非静态tour方法执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String name;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Integer age;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setName</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">getAge</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAge</span><span style="color:#24292E;">(Integer </span><span style="color:#E36209;">age</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Son</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Father</span><span style="color:#24292E;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的静态代码块{}执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的非静态代码块{}执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Son</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//super(); 默认执行Father的无参构造</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的无参构造structure 执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Son</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">, Integer </span><span style="color:#E36209;">age</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//super(); 默认执行Father的无参构造</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(name,age); </span><span style="color:#6A737D;">//执行Father的有参构造</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的有参构造structure 执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Read</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的静态Read方法执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">tour</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;子类的非静态tour方法执行了。。。&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String name;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Integer age;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setName</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Integer </span><span style="color:#6F42C1;">getAge</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAge</span><span style="color:#24292E;">(Integer </span><span style="color:#E36209;">age</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.age </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> age;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MainTest</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {      </span></span>
<span class="line"><span style="color:#24292E;">        Son son </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Son</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;======================&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        Son son1 </span><span style="color:#D73A49;">=new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Son</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;谭谭&quot;</span><span style="color:#24292E;">,</span><span style="color:#005CC5;">32</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">输出结果：</span></span>
<span class="line"><span style="color:#6A737D;">父类的静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">子类的静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">父类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">父类的无参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">子类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">子类的无参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">======================</span></span>
<span class="line"><span style="color:#6A737D;">父类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">父类的有参构造structure 执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">子类的非静态代码块{}执行了。。。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">子类的有参构造structure 执行了。。。</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span></code></pre></div><h2 id="java中的集合" tabindex="-1">JAVA中的集合 <a class="header-anchor" href="#java中的集合" aria-label="Permalink to &quot;JAVA中的集合&quot;">​</a></h2><p>集合可以分为Collection（单列集合）和Map（双列集合）</p><ul><li>Collection又可以分为Set（不可存储重复元素）和List（可存储重复元素） <ul><li>Set又可以分为HashSethe和TreeSet</li><li>List又可以分为ArrayList，LinkedList和Vector</li></ul></li><li>Map又可以分为HashMap和TreeMap <img src="`+B+'" alt="Collection"><img src="'+E+`" alt="Map"></li></ul><h2 id="数据库表中加索引的情况" tabindex="-1">数据库表中加索引的情况 <a class="header-anchor" href="#数据库表中加索引的情况" aria-label="Permalink to &quot;数据库表中加索引的情况&quot;">​</a></h2><h3 id="适合加索引的情况" tabindex="-1">适合加索引的情况 <a class="header-anchor" href="#适合加索引的情况" aria-label="Permalink to &quot;适合加索引的情况&quot;">​</a></h3><ol><li>字段的数值具有唯一性限制 <ul><li>业务上具有唯一特性的字段，即便是组合字段，也必须建成唯一索引，这种唯一索引对insert的速度损耗可以忽略，但能显著提高查找速度。</li></ul></li><li>频繁作为WHERE查询条件的字段 <ul><li>如果某个字段在SELECT语句的WHERE条件中经常被使用，那么就需要给这个字段创建索引。尤其是在数据量大的情况下，创建普通索引都可以大幅提升数据查询的效率。</li></ul></li><li>经常 GROUP BY 和 ORDER BY 的列 <ul><li>索引就是让数据按照某种顺序进行存储或检索，当对数据进行分组查询或排序的时候，就需要对分组或者排序的字段进行索引。</li><li>如果待排序的列有多个，那么可以在这些列上建立组合索引。</li></ul></li><li>需要 UPDATE 和 DELET 的 WHERE 条件列 <ul><li>当按条件查询再进行 UPDATE 和 DELETE 操作时（先查再改），如果对 WHERE 字段创建了索引，就能大幅提升效率。</li><li>原理： 因为我们需要先使用 WHERE 检录出这些记录，随后再对其进行更新或删除。如果更新的字段是非索引字段，提升的效率会更明显，因为更新非索引字段不需要维护已有索引。</li></ul></li><li>DISTINCT 字段需要创建索引 <ul><li>当需要对某个字段进行去重，使用DISTINCT时，对这个字段创建索引，也会提升查询效率。</li><li>索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</li></ul></li><li>多表 JOIN 连接操作时，创建索引注意事项 <ul><li>连接表的数量尽量不要超过3张：因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响效率。</li><li>对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。</li><li>对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致 。</li></ul></li><li>使用列的类型小的创建索引</li><li>使用字符串前缀创建索引 <ul><li>截取前缀时过多达不到节省索引存储空间的目的，过少则会因为重复内容太多从而导致字段的散列度（选择性）降低。</li><li>在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</li><li>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 count(distinct left(列名, 索引长度)) / count(*)的区分度来确定。</li></ul></li><li>区分度高(散列性高)的列适合作为索引</li><li>使用最频繁的列放到联合索引的左侧 <ul><li>这样也可以较少的建立一些索引。同时，由于&quot;最左前缀原则&quot;，可以增加联合索引的使用率。</li></ul></li><li>在多个字段都要创建索引的情况下，联合索引优于单值索引</li></ol><h3 id="不适合加索引的情况" tabindex="-1">不适合加索引的情况 <a class="header-anchor" href="#不适合加索引的情况" aria-label="Permalink to &quot;不适合加索引的情况&quot;">​</a></h3><ol><li>在 WHERE 中使用不到的字段，不要设置索引</li><li>数据量小的表（少于1000行）最好不要使用索引</li><li>有大量重复数据的列上不要建立索引 <ul><li>举例：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。   当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。</li></ul></li><li>避免对经常更新的表创建过多的索引</li><li>不建议用无序的值作为索引 <ul><li>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</li></ul></li><li>删除不再使用或者很少使用的索引</li><li>不要定义冗余或重复的索引</li></ol><h2 id="字符常量与字符串常量有什么区别" tabindex="-1">字符常量与字符串常量有什么区别 <a class="header-anchor" href="#字符常量与字符串常量有什么区别" aria-label="Permalink to &quot;字符常量与字符串常量有什么区别&quot;">​</a></h2><h3 id="_1-数据类型" tabindex="-1">1.数据类型 <a class="header-anchor" href="#_1-数据类型" aria-label="Permalink to &quot;1.数据类型&quot;">​</a></h3><ul><li>char(字符型)为基本数据类型；</li><li>string(字符串型)为引用数据类型；</li></ul><h3 id="_2-表示方式" tabindex="-1">2.表示方式 <a class="header-anchor" href="#_2-表示方式" aria-label="Permalink to &quot;2.表示方式&quot;">​</a></h3><ul><li>char(字符型)用单引号引起的单个字符；</li><li>string(字符串型)用双引号引起的0个或者多个字符；</li></ul><h3 id="_3-表达含义" tabindex="-1">3.表达含义 <a class="header-anchor" href="#_3-表达含义" aria-label="Permalink to &quot;3.表达含义&quot;">​</a></h3><ul><li>char(字符型)表示一个整形的值(ASCII值)，可以进行表达式运算，可以与整形数据类型进行转换；</li><li>string(字符串型)表示的是一个内存地址的值，即该字符串存放在内存中的位置；</li></ul><h3 id="_4-内存大小" tabindex="-1">4.内存大小 <a class="header-anchor" href="#_4-内存大小" aria-label="Permalink to &quot;4.内存大小&quot;">​</a></h3><ul><li>char(字符型)占用两个字节；</li><li>string(字符串型)占用若干个字节；</li></ul><h2 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h2><p>  在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>  在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><ul><li>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</li><li>主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。</li><li>关键代码：实现同一个接口。</li><li>应用实例： 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</li><li>优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</li><li>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#768390;">// Context上下文角色，也叫Context封装角色</span></span>
<span class="line"><span style="color:#768390;">// 起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</span></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">Context</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#768390;">// 维护一个对Strategy对象的引用  </span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> Strategy</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">strategy;</span></span>
<span class="line"><span style="color:#ADBAC7;"> </span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#768390;">// 创建的时候，通过构造函数的对象，选择对应的策略</span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#768390;">// 通过构造方法，传入具体的策略</span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Context</span><span style="color:#ADBAC7;">(Strategy </span><span style="color:#F69D50;">strategy</span><span style="color:#ADBAC7;">){</span></span>
<span class="line"><span style="color:#ADBAC7;">      </span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">.strategy </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> strategy;</span></span>
<span class="line"><span style="color:#ADBAC7;">   }</span></span>
<span class="line"><span style="color:#ADBAC7;"> </span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">executeStrategy</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num1</span><span style="color:#ADBAC7;">, </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num2</span><span style="color:#ADBAC7;">){</span></span>
<span class="line"><span style="color:#ADBAC7;">      </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> strategy.</span><span style="color:#DCBDFB;">doOperation</span><span style="color:#ADBAC7;">(num1, num2);</span></span>
<span class="line"><span style="color:#ADBAC7;">   }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">// Strategy是策略类，定义每个策略或算法必须具有的方法和属性</span></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">interface</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">Strategy</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">doOperation</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num1</span><span style="color:#ADBAC7;">, </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num2</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#768390;">// 具体策略类，封装了具体的算法或行为</span></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">OperationAdd</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">implements</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">Strategy</span><span style="color:#ADBAC7;">{</span></span>
<span class="line"><span style="color:#ADBAC7;">   @</span><span style="color:#F47067;">Override</span></span>
<span class="line"><span style="color:#ADBAC7;">   </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">doOperation</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num1</span><span style="color:#ADBAC7;">, </span><span style="color:#F47067;">int</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">num2</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">      </span><span style="color:#F47067;">return</span><span style="color:#ADBAC7;"> num1 </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> num2;</span></span>
<span class="line"><span style="color:#ADBAC7;">   }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">main</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">String</span><span style="color:#ADBAC7;">[] args) {</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">// 创建的时候，通过构造函数的对象，选择对应的策略</span></span>
<span class="line"><span style="color:#ADBAC7;">  Context</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">context</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Context</span><span style="color:#ADBAC7;">(</span><span style="color:#F47067;">new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">OperationAdd</span><span style="color:#ADBAC7;">());    </span></span>
<span class="line"><span style="color:#ADBAC7;">  System.out.</span><span style="color:#DCBDFB;">println</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;10 + 5 = &quot;</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">+</span><span style="color:#ADBAC7;"> context.</span><span style="color:#DCBDFB;">executeStrategy</span><span style="color:#ADBAC7;">(</span><span style="color:#6CB6FF;">10</span><span style="color:#ADBAC7;">, </span><span style="color:#6CB6FF;">5</span><span style="color:#ADBAC7;">));</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// Context上下文角色，也叫Context封装角色</span></span>
<span class="line"><span style="color:#6A737D;">// 起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Context</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 维护一个对Strategy对象的引用  </span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Strategy strategy;</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 创建的时候，通过构造函数的对象，选择对应的策略</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 通过构造方法，传入具体的策略</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Context</span><span style="color:#24292E;">(Strategy </span><span style="color:#E36209;">strategy</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.strategy </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> strategy;</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">executeStrategy</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num1</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num2</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> strategy.</span><span style="color:#6F42C1;">doOperation</span><span style="color:#24292E;">(num1, num2);</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Strategy是策略类，定义每个策略或算法必须具有的方法和属性</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Strategy</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doOperation</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num1</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num2</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 具体策略类，封装了具体的算法或行为</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">OperationAdd</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Strategy</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">   @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doOperation</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num1</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">num2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> num1 </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> num2;</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建的时候，通过构造函数的对象，选择对应的策略</span></span>
<span class="line"><span style="color:#24292E;">  Context context </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Context</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">OperationAdd</span><span style="color:#24292E;">());    </span></span>
<span class="line"><span style="color:#24292E;">  System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;10 + 5 = &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> context.</span><span style="color:#6F42C1;">executeStrategy</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="springboot-中实现跨域的方式" tabindex="-1">SpringBoot 中实现跨域的方式 <a class="header-anchor" href="#springboot-中实现跨域的方式" aria-label="Permalink to &quot;SpringBoot 中实现跨域的方式&quot;">​</a></h2><p>  域：协议 + 域名 + 端口；三者完全相同则为同域，反之有其一不同均为不同域。</p><p>  跨域请求：当前【发起请求】的域和【请求指向】的域属于不同域时，该次请求称之为跨域请求。</p><h3 id="全局跨域" tabindex="-1">全局跨域 <a class="header-anchor" href="#全局跨域" aria-label="Permalink to &quot;全局跨域&quot;">​</a></h3><ol><li>返回新的CorsFilter <ul><li>在任意配置类，返回一个新的CorsFIlter的Bean ，并添加映射路径和具体的CORS配置路径</li></ul></li><li>重写WebMvcConfigurer接口的addCorsMappings方法</li></ol><h3 id="局部跨域" tabindex="-1">局部跨域 <a class="header-anchor" href="#局部跨域" aria-label="Permalink to &quot;局部跨域&quot;">​</a></h3><ol><li>使用注解@CrossOrigin <ul><li>在类上上使用注解，表示该类的所有方法允许跨域；也可以在方法上使用注解。</li></ul></li><li>手动设置响应头 (HttpServletResponse) <ul><li>response.addHeader(&quot;Access-Allow-Control-Origin&quot;,&quot;*&quot;)</li></ul></li></ol><h2 id="spring的依赖注入-降低程序间的耦合-依赖关系" tabindex="-1">Spring的依赖注入：降低程序间的耦合（依赖关系） <a class="header-anchor" href="#spring的依赖注入-降低程序间的耦合-依赖关系" aria-label="Permalink to &quot;Spring的依赖注入：降低程序间的耦合（依赖关系）&quot;">​</a></h2><p>  将创建对象的管理交给spring容器，由Spring为我们提供，我们只需要在配置文件中说明依赖关系的维护</p><h3 id="依赖注入能注入的数据" tabindex="-1">依赖注入能注入的数据 <a class="header-anchor" href="#依赖注入能注入的数据" aria-label="Permalink to &quot;依赖注入能注入的数据&quot;">​</a></h3><ul><li>基本数据类型和String</li><li>其他bean类型（在配置文件中或者注解配置过的bean）</li><li>复杂类型/集合类型</li></ul><h3 id="注入的方式" tabindex="-1">注入的方式 <a class="header-anchor" href="#注入的方式" aria-label="Permalink to &quot;注入的方式&quot;">​</a></h3><ul><li>使用构造函数提供</li><li>使用set方法提供</li><li>使用注解提供</li></ul><h2 id="redis-5种数据结构以及使用场景" tabindex="-1">redis 5种数据结构以及使用场景 <a class="header-anchor" href="#redis-5种数据结构以及使用场景" aria-label="Permalink to &quot;redis 5种数据结构以及使用场景&quot;">​</a></h2><h3 id="string-字符串" tabindex="-1">String（字符串） <a class="header-anchor" href="#string-字符串" aria-label="Permalink to &quot;String（字符串）&quot;">​</a></h3><ul><li>计数器</li><li>随机验证码</li></ul><h3 id="hash-字典" tabindex="-1">Hash（字典） <a class="header-anchor" href="#hash-字典" aria-label="Permalink to &quot;Hash（字典）&quot;">​</a></h3><ul><li>存储对象类型的数据（如用户信息数据）</li></ul><h3 id="list-列表" tabindex="-1">List（列表） <a class="header-anchor" href="#list-列表" aria-label="Permalink to &quot;List（列表）&quot;">​</a></h3><ul><li>消息队列</li><li>用户消息时间线</li><li>文章的评论列表</li></ul><h3 id="set-集合" tabindex="-1">Set（集合） <a class="header-anchor" href="#set-集合" aria-label="Permalink to &quot;Set（集合）&quot;">​</a></h3><ul><li>标签</li><li>共同好友（两个set实现交集、并集、差集）</li></ul><h3 id="sorted-set-有序集合" tabindex="-1">Sorted Set（有序集合） <a class="header-anchor" href="#sorted-set-有序集合" aria-label="Permalink to &quot;Sorted Set（有序集合）&quot;">​</a></h3><ul><li>排行榜</li></ul><h2 id="http-协议" tabindex="-1">HTTP 协议 <a class="header-anchor" href="#http-协议" aria-label="Permalink to &quot;HTTP 协议&quot;">​</a></h2><p>  HTTP 协议是一种基于文本的传输协议，HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密</p><h3 id="http-中间人攻击" tabindex="-1">HTTP 中间人攻击 <a class="header-anchor" href="#http-中间人攻击" aria-label="Permalink to &quot;HTTP 中间人攻击&quot;">​</a></h3><p>  在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全</p><h3 id="防止中间人攻击" tabindex="-1">防止中间人攻击 <a class="header-anchor" href="#防止中间人攻击" aria-label="Permalink to &quot;防止中间人攻击&quot;">​</a></h3><ul><li>对称加密（双方约定加密方式）：在第一次传输的时候，约定使用何种加密方式。如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信；</li><li>非对称加密：在约定加密方式的时候由服务器生成一对公私钥，服务器将公钥返回给客户端，客户端本地生成一串秘钥(AES_KEY)用于对称加密，并通过服务器发送的公钥进行加密得到(AES_KEY_SECRET)，之后返回给服务端，服务端通过私钥将客户端发送的AES_KEY_SECRET进行解密得到AEK_KEY,最后客户端和服务器通过AEK_KEY进行报文的加密通讯，改造如下 <img src="`+F+'" alt="AsymmetricEncryption"></li></ul><p>非对称加密也不安全：中间人既然拿不到AES_KEY，那我就把自己模拟成一个客户端和服务器端的结合体，在用户-&gt;中间人的过程中中间人模拟服务器的行为，这样可以拿到用户请求的明文，在中间人-&gt;服务器的过程中中间人模拟客户端行为，这样可以拿到服务器响应的明文，以此来进行中间人攻击 <img src="'+m+`" alt="Middleman"></p><h2 id="https-协议" tabindex="-1">HTTPS 协议 <a class="header-anchor" href="#https-协议" aria-label="Permalink to &quot;HTTPS 协议&quot;">​</a></h2><ul><li>HTTPS 其实是SSL+HTTP的简称；服务器是通过 SSL 证书来传递公钥，客户端会对 SSL 证书进行验证，其中证书认证体系就是确保SSL安全的关键。</li><li>权威认证机构在CA认证体系中，所有的证书都是由权威机构来颁发，而权威机构的 CA 证书都是已经在操作系统中内置的，我们把这些证书称之为CA根证书；</li></ul><h2 id="tcp-udp" tabindex="-1">TCP，UDP <a class="header-anchor" href="#tcp-udp" aria-label="Permalink to &quot;TCP，UDP&quot;">​</a></h2><ol><li>TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性。 UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。</li><li>也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</li><li>TCP适用于传输大量的数据，UDP适用于传输少量的数据。</li></ol><h2 id="resource和-autowired" tabindex="-1">@Resource和@Autowired <a class="header-anchor" href="#resource和-autowired" aria-label="Permalink to &quot;@Resource和@Autowired&quot;">​</a></h2><ul><li>@Resource和@Autowired都是做bean的注入时使用</li><li>@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</li><li>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</li></ul><h3 id="autowired" tabindex="-1">@Autowired <a class="header-anchor" href="#autowired" aria-label="Permalink to &quot;@Autowired&quot;">​</a></h3><ul><li>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。</li><li>如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</li></ul><h3 id="resource" tabindex="-1">@Resource <a class="header-anchor" href="#resource" aria-label="Permalink to &quot;@Resource&quot;">​</a></h3><ul><li>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</li><li>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。</li><li>所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li></ul><h2 id="springboot-读取配置文件的注解" tabindex="-1">Springboot 读取配置文件的注解 <a class="header-anchor" href="#springboot-读取配置文件的注解" aria-label="Permalink to &quot;Springboot 读取配置文件的注解&quot;">​</a></h2><h3 id="value" tabindex="-1">@Value <a class="header-anchor" href="#value" aria-label="Permalink to &quot;@Value&quot;">​</a></h3><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#96D0FF;">application.properties：</span></span>
<span class="line"><span style="color:#96D0FF;">demo.name=Name</span></span>
<span class="line"><span style="color:#96D0FF;">demo.age=18</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">application.properties：</span></span>
<span class="line"><span style="color:#032F62;">demo.name=Name</span></span>
<span class="line"><span style="color:#032F62;">demo.age=18</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">Value</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;\${demo.name}&quot;</span><span style="color:#ADBAC7;">)</span></span>
<span class="line"><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> String</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">name;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Value</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;\${demo.name}&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String name;</span></span></code></pre></div><h3 id="configurationproperties" tabindex="-1">@ConfigurationProperties <a class="header-anchor" href="#configurationproperties" aria-label="Permalink to &quot;@ConfigurationProperties&quot;">​</a></h3><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#96D0FF;">application.properties：</span></span>
<span class="line"><span style="color:#96D0FF;">demo.phone=10086</span></span>
<span class="line"><span style="color:#96D0FF;">demo.wife=self</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">application.properties：</span></span>
<span class="line"><span style="color:#032F62;">demo.phone=10086</span></span>
<span class="line"><span style="color:#032F62;">demo.wife=self</span></span></code></pre></div><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">Component</span></span>
<span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">ConfigurationProperties</span><span style="color:#ADBAC7;">(</span><span style="color:#6CB6FF;">prefix</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;demo&quot;</span><span style="color:#ADBAC7;">)    </span><span style="color:#768390;">//用于绑定属性，其中prefix表示所绑定的属性的前缀</span></span>
<span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">PropertySource</span><span style="color:#ADBAC7;">(</span><span style="color:#6CB6FF;">value</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;config.properties&quot;</span><span style="color:#ADBAC7;">) </span><span style="color:#768390;">// 表示配置文件路径</span></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">ConfigBeanProp</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#768390;">// 属性名称和配置文件的name一致</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> String</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">phone;</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> String</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">wife;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Component</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">ConfigurationProperties</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">prefix</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;demo&quot;</span><span style="color:#24292E;">)    </span><span style="color:#6A737D;">//用于绑定属性，其中prefix表示所绑定的属性的前缀</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">PropertySource</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;config.properties&quot;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 表示配置文件路径</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ConfigBeanProp</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 属性名称和配置文件的name一致</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String phone;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String wife;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="线程安全" tabindex="-1">线程安全 <a class="header-anchor" href="#线程安全" aria-label="Permalink to &quot;线程安全&quot;">​</a></h2><ul><li>多个线程访问同一个对象时，不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</li><li>一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。</li><li>线程安全问题大多是由全局变量及静态变量引起的，局部变量逃逸也可能导致线程安全问题。</li><li>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</li></ul><h2 id="synchronized" tabindex="-1">@synchronized <a class="header-anchor" href="#synchronized" aria-label="Permalink to &quot;@synchronized&quot;">​</a></h2><p>  @synchronized 的作用是创建一个互斥锁，保证此时没有其它线程对self对象进行修改，保证代码的安全性。也就是包装这段代码是原子性的，安全的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">class</span><span style="color:#ADBAC7;"> </span><span style="color:#F69D50;">RetryTest1</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">int</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">i</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">private</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">int</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">s</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">0</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">//线程不安全</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">add</span><span style="color:#ADBAC7;">(){ </span></span>
<span class="line"><span style="color:#ADBAC7;">    s</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">//线程安全.因为i是非静态变量，即每个类对象拥有各自的变量。这里synchronized(this)意思就是本类对象的意思。所以是线程安全的。</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">addSyncI</span><span style="color:#ADBAC7;">(){ </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">synchronized</span><span style="color:#ADBAC7;"> (</span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">      i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">//线程不安全.因为s是静态变量，这里synchronized(this)意思就是本类对象的意思。</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">addSyncS</span><span style="color:#ADBAC7;">(){ </span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">synchronized</span><span style="color:#ADBAC7;"> (</span><span style="color:#6CB6FF;">this</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">      s</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">    }</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">//线程不安全.因为s是静态变量，而synchronized修饰的是非静态方法，即如果多线程中同时调用不同类对象的该方法，就会有问题。</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">synchronized</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">addSyncFun</span><span style="color:#ADBAC7;">(){ </span></span>
<span class="line"><span style="color:#ADBAC7;">    s</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#768390;">//线程安全.因为synchronized修饰的是静态方法，即这个方法本身任何情况下都是互斥的，所以是线程安全的。</span></span>
<span class="line"><span style="color:#ADBAC7;">  </span><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">static</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">synchronized</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">addSyncStaticFun</span><span style="color:#ADBAC7;">(){ </span></span>
<span class="line"><span style="color:#ADBAC7;">    s</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">  }</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RetryTest1</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//线程不安全</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(){ </span></span>
<span class="line"><span style="color:#24292E;">    s</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//线程安全.因为i是非静态变量，即每个类对象拥有各自的变量。这里synchronized(this)意思就是本类对象的意思。所以是线程安全的。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addSyncI</span><span style="color:#24292E;">(){ </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//线程不安全.因为s是静态变量，这里synchronized(this)意思就是本类对象的意思。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addSyncS</span><span style="color:#24292E;">(){ </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      s</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//线程不安全.因为s是静态变量，而synchronized修饰的是非静态方法，即如果多线程中同时调用不同类对象的该方法，就会有问题。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addSyncFun</span><span style="color:#24292E;">(){ </span></span>
<span class="line"><span style="color:#24292E;">    s</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//线程安全.因为synchronized修饰的是静态方法，即这个方法本身任何情况下都是互斥的，所以是线程安全的。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addSyncStaticFun</span><span style="color:#24292E;">(){ </span></span>
<span class="line"><span style="color:#24292E;">    s</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="数据库中引起全表扫描的sql语句" tabindex="-1">数据库中引起全表扫描的SQL语句 <a class="header-anchor" href="#数据库中引起全表扫描的sql语句" aria-label="Permalink to &quot;数据库中引起全表扫描的SQL语句&quot;">​</a></h2><h3 id="_1、模糊查询-like" tabindex="-1">1、模糊查询（like） <a class="header-anchor" href="#_1、模糊查询-like" aria-label="Permalink to &quot;1、模糊查询（like）&quot;">​</a></h3><ul><li>原因：like本身效率就比较低，应该尽量避免查询条件使用like；对于like ‘%...%’（全模糊）这样的条件，是无法使用索引的，全表扫描自然效率很低；另外，由于匹配算法的关系，模糊查询的字段长度越大，模糊查询效率越低。</li><li>解决办法：首先尽量避免模糊查询，如果因为业务需要一定要使用模糊查询，则至少保证不要使用全模糊查询： <ul><li>对于右模糊查询，即like ‘…%’，是会使用索引的；</li><li>左模糊like‘%...’无法直接使用索引，但可以利用reverse + function index 的形式，变化成 like ‘…%’；</li><li>全模糊是无法优化的，一定要的话考虑用搜索引擎。出于降低数据库服务器的负载考虑，尽可能地减少数据库模糊查询。</li></ul></li></ul><h3 id="_2、查询条件中含有is-null" tabindex="-1">2、查询条件中含有is null <a class="header-anchor" href="#_2、查询条件中含有is-null" aria-label="Permalink to &quot;2、查询条件中含有is null&quot;">​</a></h3><ul><li>原因：Oracle 9i中，查询字段is null时单索引失效，引起全表扫描。</li><li>解决方法：SQL语法中使用NULL会有很多麻烦，最好索引列都是NOT NULL的；对于is null，可以建立组合索引，nvl(字段,0),对表和索引analyse后，is null查询时可以重新启用索引查找,但是效率还不是值得肯定；is not null 时永远不会使用索引。一般数据量大的表不要用is null查询。</li></ul><h3 id="_3、查询条件中有不等于操作符-、" tabindex="-1">3、查询条件中有不等于操作符（&lt;&gt;、!=） <a class="header-anchor" href="#_3、查询条件中有不等于操作符-、" aria-label="Permalink to &quot;3、查询条件中有不等于操作符（&lt;&gt;、!=）&quot;">​</a></h3><ul><li>原因：SQL中，不等于操作符会限制索引，引起全表扫描，即使比较的字段上有索引。</li><li>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描。例如，把column&lt;&gt;’aaa’，改成column&lt;’aaa’ or column&gt;’aaa’，就可以使用索引了。</li></ul><h3 id="_4、or使用不当" tabindex="-1">4、or使用不当 <a class="header-anchor" href="#_4、or使用不当" aria-label="Permalink to &quot;4、or使用不当&quot;">​</a></h3><ul><li>原因：where子句中比较的两个条件，一个有索引，一个没索引，使用or则会引起全表扫描。例如：where A==1 or B==2，A上有索引，B上没索引，则比较B==2时会重新开始全表扫描。</li></ul><h3 id="_5、组合索引" tabindex="-1">5、组合索引 <a class="header-anchor" href="#_5、组合索引" aria-label="Permalink to &quot;5、组合索引&quot;">​</a></h3><ul><li>排序时应按照组合索引中各列的顺序进行排序，即使索引中只有一个列是要排序的，否则排序性能会比较差。</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">create</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">index</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">skip1</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">on</span><span style="color:#ADBAC7;"> emp5(job,empno，</span><span style="color:#F47067;">date</span><span style="color:#ADBAC7;">); </span></span>
<span class="line"><span style="color:#F47067;">select</span><span style="color:#ADBAC7;"> job，empno </span><span style="color:#F47067;">from</span><span style="color:#ADBAC7;"> emp5 </span><span style="color:#F47067;">where</span><span style="color:#ADBAC7;"> job</span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;">’manager’</span><span style="color:#F47067;">and</span><span style="color:#ADBAC7;"> empno</span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;">’</span><span style="color:#6CB6FF;">10</span><span style="color:#ADBAC7;">’ </span><span style="color:#F47067;">order by</span><span style="color:#ADBAC7;"> job,empno,</span><span style="color:#F47067;">date</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">desc</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#768390;">-- 实际上只是查询出符合job=’manager’and empno=’10’条件的记录并按date降序排列，</span></span>
<span class="line"><span style="color:#768390;">-- 但是如果只写成order by date desc性能较差。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">create</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">index</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">skip1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">on</span><span style="color:#24292E;"> emp5(job,empno，</span><span style="color:#D73A49;">date</span><span style="color:#24292E;">); </span></span>
<span class="line"><span style="color:#D73A49;">select</span><span style="color:#24292E;"> job，empno </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> emp5 </span><span style="color:#D73A49;">where</span><span style="color:#24292E;"> job</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">’manager’</span><span style="color:#D73A49;">and</span><span style="color:#24292E;"> empno</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">’</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">’ </span><span style="color:#D73A49;">order by</span><span style="color:#24292E;"> job,empno,</span><span style="color:#D73A49;">date</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">desc</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">-- 实际上只是查询出符合job=’manager’and empno=’10’条件的记录并按date降序排列，</span></span>
<span class="line"><span style="color:#6A737D;">-- 但是如果只写成order by date desc性能较差。</span></span></code></pre></div><h3 id="_6、在where子句中对字段进行函数操作" tabindex="-1">6、在where子句中对字段进行函数操作 <a class="header-anchor" href="#_6、在where子句中对字段进行函数操作" aria-label="Permalink to &quot;6、在where子句中对字段进行函数操作&quot;">​</a></h3><ul><li>在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li></ul><h3 id="_7、不带任何条件的count" tabindex="-1">7、不带任何条件的count <a class="header-anchor" href="#_7、不带任何条件的count" aria-label="Permalink to &quot;7、不带任何条件的count&quot;">​</a></h3><ul><li>select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</li></ul><h3 id="_8、update-语句" tabindex="-1">8、Update 语句 <a class="header-anchor" href="#_8、update-语句" aria-label="Permalink to &quot;8、Update 语句&quot;">​</a></h3><ul><li>如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</li></ul><h2 id="spring中使用到的设计模式" tabindex="-1">Spring中使用到的设计模式 <a class="header-anchor" href="#spring中使用到的设计模式" aria-label="Permalink to &quot;Spring中使用到的设计模式&quot;">​</a></h2><h3 id="_1、工厂设计模式" tabindex="-1">1、工厂设计模式 <a class="header-anchor" href="#_1、工厂设计模式" aria-label="Permalink to &quot;1、工厂设计模式&quot;">​</a></h3><ul><li>Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。</li></ul><h3 id="_2、单例设计模式" tabindex="-1">2、单例设计模式 <a class="header-anchor" href="#_2、单例设计模式" aria-label="Permalink to &quot;2、单例设计模式&quot;">​</a></h3><ul><li>线程池、缓存、日志对象</li><li>Spring 中 bean 的默认作用域就是 singleton(单例)的。</li></ul><h3 id="_3、代理模式" tabindex="-1">3、代理模式 <a class="header-anchor" href="#_3、代理模式" aria-label="Permalink to &quot;3、代理模式&quot;">​</a></h3><ul><li>AOP（基于动态代理） 如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。Spring AOP 属于运行时增强，而 AspectJ 是编译时增强</li></ul><h3 id="_4、模板方法" tabindex="-1">4、模板方法 <a class="header-anchor" href="#_4、模板方法" aria-label="Permalink to &quot;4、模板方法&quot;">​</a></h3><p>  模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式</p><ul><li>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</li></ul><h3 id="_5、观察者模式" tabindex="-1">5、观察者模式 <a class="header-anchor" href="#_5、观察者模式" aria-label="Permalink to &quot;5、观察者模式&quot;">​</a></h3><p>  观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。</p><ul><li>Spring 事件驱动模型</li></ul><h3 id="_6、适配器模式" tabindex="-1">6、适配器模式 <a class="header-anchor" href="#_6、适配器模式" aria-label="Permalink to &quot;6、适配器模式&quot;">​</a></h3><p>  适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><ul><li>Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式</li><li>在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。</li></ul><h3 id="_7、装饰者模式" tabindex="-1">7、装饰者模式 <a class="header-anchor" href="#_7、装饰者模式" aria-label="Permalink to &quot;7、装饰者模式&quot;">​</a></h3><p>  装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。</p><ul><li>InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。</li></ul><h2 id="ioc的作用" tabindex="-1">ioc的作用 <a class="header-anchor" href="#ioc的作用" aria-label="Permalink to &quot;ioc的作用&quot;">​</a></h2><p>  ioc的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。</p><ul><li>第一，资源集中管理，实现资源的可配置和易管理。</li><li>第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</li></ul><h2 id="equals与-的区别" tabindex="-1">equals与==的区别 <a class="header-anchor" href="#equals与-的区别" aria-label="Permalink to &quot;equals与==的区别&quot;">​</a></h2><ol><li>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较</li><li>==指引用是否相同， equals()指的是值是否相同</li></ol><h2 id="为什么重写equals方法-还必须要重写hashcode方法" tabindex="-1">为什么重写equals方法，还必须要重写hashcode方法 <a class="header-anchor" href="#为什么重写equals方法-还必须要重写hashcode方法" aria-label="Permalink to &quot;为什么重写equals方法，还必须要重写hashcode方法&quot;">​</a></h2><ol><li>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率（hashcode不等，equals一定不等，则无需比较equals，提升效率。hashcode相等，equals可能相等，也可能不等。)</li><li>保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</li><li>HashSet内部不允许重复元素，HashSet添加数据的时候，是通过HashCode和equals方法都会true的时候才会判断两个元素完全相同</li></ol><p>  不被重写（原生）的hashCode值是根据内存地址换算出来的一个值</p><h2 id="tostring-、string-valueof、-string-强转-区别" tabindex="-1">toString()、String.valueOf、(String)强转，区别 <a class="header-anchor" href="#tostring-、string-valueof、-string-强转-区别" aria-label="Permalink to &quot;toString()、String.valueOf、(String)强转，区别&quot;">​</a></h2><ul><li>1、toString()，可能会抛空指针异常 <ul><li>在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。</li></ul></li><li>2、String.valueOf()，推荐使用，返回字符串“null” <ul><li>String.valueOf()方法不会出现空指针异常，而且是静态的方法，直接通过String调用即可，只是有一点需要注意，就是上面提到的，如果为null，String.valueOf()返回结果是字符串“null”。而不是null。</li></ul></li><li>3、(String)强转，不推荐使用 <ul><li>（String）是标准的类型转换，将Object类型转为String类型，使用(String)强转时，最好使用instanceof做一个类型检查，以判断是否可以进行强转，否则容易抛出ClassCastException异常。需要注意的是编写的时候，编译器并不会提示有语法错误，所以这个方法要谨慎的使用。</li></ul></li></ul><h2 id="常见加密算法简析" tabindex="-1">常见加密算法简析 <a class="header-anchor" href="#常见加密算法简析" aria-label="Permalink to &quot;常见加密算法简析&quot;">​</a></h2><h3 id="_1、对称加密算法-aes、des、3des" tabindex="-1">1、对称加密算法（AES、DES、3DES） <a class="header-anchor" href="#_1、对称加密算法-aes、des、3des" aria-label="Permalink to &quot;1、对称加密算法（AES、DES、3DES）&quot;">​</a></h3><p>  对称加密算法是指加密和解密采用相同的密钥，是可逆的（即可解密）。</p><p>  AES加密算法是密码学中的高级加密标准，采用的是对称分组密码体制，密钥长度的最少支持为128。AES加密算法是美国联邦政府采用的区块加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界使用。</p><ul><li>优点：加密速度快</li><li>缺点：密钥的传递和保存是一个问题，参与加密和解密的双方使用的密钥是一样的，这样密钥就很容易泄露。</li></ul><h3 id="_2、非对称加密算法-rsa、dsa、ecc" tabindex="-1">2、非对称加密算法（RSA、DSA、ECC） <a class="header-anchor" href="#_2、非对称加密算法-rsa、dsa、ecc" aria-label="Permalink to &quot;2、非对称加密算法（RSA、DSA、ECC）&quot;">​</a></h3><p>  非对称加密算法是指加密和解密采用不同的密钥（公钥和私钥），因此非对称加密也叫公钥加密，是可逆的（即可解密）。公钥密码体制根据其所依据的难题一般分为三类：大素数分解问题类、离散对数问题类、椭圆曲线类。</p><p>  RSA加密算法是基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解极其困难，因此可以将乘积公开作为加密密钥。虽然RSA的安全性一直未能得到理论上的证明，但它经历了各种攻击至今未被完全攻破。</p><ul><li>优点：加密和解密的密钥不一致，公钥是可以公开的，只需保证私钥不被泄露即可，这样就密钥的传递变的简单很多，从而降低了被破解的几率。</li><li>缺点：加密速度慢</li></ul><h4 id="rsa加密算法既可以用来做数据加密-也可以用来数字签名。" tabindex="-1">RSA加密算法既可以用来做数据加密，也可以用来数字签名。 <a class="header-anchor" href="#rsa加密算法既可以用来做数据加密-也可以用来数字签名。" aria-label="Permalink to &quot;RSA加密算法既可以用来做数据加密，也可以用来数字签名。&quot;">​</a></h4><ul><li>数据加密过程：发送者用公钥加密，接收者用私钥解密（只有拥有私钥的接收者才能解读加密的内容）</li><li>数字签名过程：甲方用私钥加密，乙方用公钥解密（乙方解密成功说明就是甲方加的密，甲方就不可以抵赖）</li></ul><h3 id="_3、线性散列算法算法-md5、sha1、hmac" tabindex="-1">3、线性散列算法算法（MD5、SHA1、HMAC） <a class="header-anchor" href="#_3、线性散列算法算法-md5、sha1、hmac" aria-label="Permalink to &quot;3、线性散列算法算法（MD5、SHA1、HMAC）&quot;">​</a></h3><p>  MD5全称是Message-Digest Algorithm 5（信息摘要算法5），单向的算法不可逆（被MD5加密的数据不能被解密）。MD5加密后的数据长度要比加密数据小的多，且长度固定，且加密后的串是唯一的。</p><p>  适用场景：常用在不可还原的密码存储、信息完整性校验等。</p><p>  信息完整性校验：典型的应用是对一段信息产生信息摘要，以防止被篡改。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</p><h4 id="sha-1-与-md5-的比较" tabindex="-1">SHA-1 与 MD5 的比较 <a class="header-anchor" href="#sha-1-与-md5-的比较" aria-label="Permalink to &quot;SHA-1 与 MD5 的比较&quot;">​</a></h4><p>  SHA-1摘要比MD5摘要长32 位，所以SHA-1对强行攻击有更大的强度，比MD5更安全。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2^128数量级的操作，而对SHA-1则是2^160数量级的操作。</p><p>  在相同的硬件上，SHA-1 的运行速度比 MD5 慢。</p><h3 id="_4、混合加密" tabindex="-1">4、混合加密 <a class="header-anchor" href="#_4、混合加密" aria-label="Permalink to &quot;4、混合加密&quot;">​</a></h3><p>  由于以上加密算法都有各自的缺点（RSA加密速度慢、AES密钥存储问题、MD5加密不可逆），因此实际应用时常将几种加密算法混合使用。</p><p>  例如：RSA+AES：采用RSA加密AES的密钥，采用AES对数据进行加密，这样集成了两种加密算法的优点，既保证了数据加密的速度，又实现了安全方便的密钥管理。</p><h4 id="采用多少位的密钥合适" tabindex="-1">采用多少位的密钥合适 <a class="header-anchor" href="#采用多少位的密钥合适" aria-label="Permalink to &quot;采用多少位的密钥合适&quot;">​</a></h4><p>  一般来讲密钥长度越长，安全性越高，但是加密速度越慢。所以密钥长度也要合理的选择，一般RSA建议采用1024位的数字，AES建议采用128位即可。</p><h3 id="_5、base64" tabindex="-1">5、Base64 <a class="header-anchor" href="#_5、base64" aria-label="Permalink to &quot;5、Base64&quot;">​</a></h3><p>  严格意义讲，Base64并不能算是一种加密算法，而是一种编码格式，是网络上最常见的用于传输8bid字节代码的编码方式之一。</p><p>  Base64编码可用于在HTTP环境下传递较长的标识信息，Base编码不仅不仅比较简单，同时也据有不可读性（编码的数据不会被肉眼直接看到）。</p>`,190);function v(s,k,f,P,x,_){const r=l("Badge"),c=y,i=l("ClientOnly");return p(),D("div",null,[t("h1",g,[o("Java面试题 "),e(r,{text:"持续更新",type:"warning"}),o(),q]),e(i,null,{default:u(()=>{var a,n;return[(((a=s.$frontmatter)==null?void 0:a.aside)??!0)&&(((n=s.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(p(),h(c,{key:0,article:s.$frontmatter},null,8,["article"])):d("",!0)]}),_:1}),S])}const R=A(b,[["render",v]]);export{T as __pageData,R as default};
