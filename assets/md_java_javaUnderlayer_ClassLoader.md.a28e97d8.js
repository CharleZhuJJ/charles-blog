import{_ as i}from"./chunks/ArticleMetadata.8b6b367a.js";import{_ as n,H as c,o as s,c as d,J as h,E as p,C as r,a as _,V as m,D as u,G as f}from"./chunks/framework.981adca9.js";const b="/charles-blog/assets/JavaLoad.4c80cf47.png",C="/charles-blog/assets/ClassLoaderProcess.d14d8f96.png",g="/charles-blog/assets/Load.dd810b8c.png",q="/charles-blog/assets/ClassLoader.8c3a742f.png",y=JSON.parse('{"title":"类加载器","description":"","frontmatter":{"title":"类加载器","author":"Charles Chu","date":"2021/12/14","isOriginal":true},"headers":[],"relativePath":"md/java/javaUnderlayer/ClassLoader.md","filePath":"md/java/javaUnderlayer/ClassLoader.md","lastUpdated":1691825438000}'),v={name:"md/java/javaUnderlayer/ClassLoader.md"},P=r("h1",{id:"类加载器",tabindex:"-1"},[_("类加载器 "),r("a",{class:"header-anchor",href:"#类加载器","aria-label":'Permalink to "类加载器"'},"​")],-1),x=m('<h2 id="类加载过程" tabindex="-1">类加载过程 <a class="header-anchor" href="#类加载过程" aria-label="Permalink to &quot;类加载过程&quot;">​</a></h2><p>  当程序使用某个 Java 类时，JVM 虚拟机会加载它的.class 文件到虚拟机的内存中，负责加载工作的就是类加载器</p><p><img src="'+b+'" alt="JavaLoad"></p><p>  类加载过程分为加载、验证、准备、解析、初始化，下图是对类加载过程简单的介绍。 <img src="'+C+'" alt="ClassLoaderProcess"></p><h3 id="_1-加载" tabindex="-1">1. 加载 <a class="header-anchor" href="#_1-加载" aria-label="Permalink to &quot;1. 加载&quot;">​</a></h3><p>  原理：委托 ClassLoader 读取 Class 二进制字节流，载入到方法区内存，并在堆内存中生成对应的 java.lang.Class 对象相互引用。 <img src="'+g+'" alt="Load"></p><h3 id="_2-验证" tabindex="-1">2. 验证 <a class="header-anchor" href="#_2-验证" aria-label="Permalink to &quot;2. 验证&quot;">​</a></h3><p>  校验字节流确保符合 Class 文件格式，执行语义分析确保符合 Java 语法，校验字节码指令合法性。</p><h3 id="_3-准备" tabindex="-1">3. 准备 <a class="header-anchor" href="#_3-准备" aria-label="Permalink to &quot;3. 准备&quot;">​</a></h3><p>  在堆中分配类变量（static）内存并初始化为零值，主义还没到执行 putstatic 指令赋值的初始化阶段，但静态常量属性除外：</p><h3 id="_4-解析" tabindex="-1">4. 解析 <a class="header-anchor" href="#_4-解析" aria-label="Permalink to &quot;4. 解析&quot;">​</a></h3><p>  将常量池中的符号引用（Class_info, Fieldref_info, Methodref_info）替换为直接引用（内存地址）</p><h3 id="_5-初始化" tabindex="-1">5. 初始化 <a class="header-anchor" href="#_5-初始化" aria-label="Permalink to &quot;5. 初始化&quot;">​</a></h3><p>  javac 会从上到下合并类中 static 变量赋值、static 语句块，生成类构造器()V，在初始化阶段执行，此方法的执行由 JVM 保证线程安全；注意 JVM 规定有且仅有的，会立即触发对类初始化的六种 case</p><h2 id="类加载器-1" tabindex="-1">类加载器 <a class="header-anchor" href="#类加载器-1" aria-label="Permalink to &quot;类加载器&quot;">​</a></h2><p>  JVM 虚拟机提供了 3 种类加载器，它们分别是启动类加载器（Bootstrap）、扩展类加载器（Extension）、系统类加载器（System）。</p><p>  每个类加载器都有明确的加载范围：</p><ul><li>启动类加载器（Bootstrap）：加载&lt;JAVA_HOME&gt;/lib 路径下的核心类库</li><li>扩展类加载器（Extension）：加载&lt;JAVA_HOME&gt;/lib/extl 路径下的</li><li>系统类加载器（System）：加载系统类路径 classpath，也就是我们经常用到的 classpath 路径，一般情况该类加载器是程序中默认的类加载器 <img src="'+q+'" alt="ClassLoader"></li></ul><h2 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h2><p>  双亲委派模式是为了避免重复加载和核心类篡改。</p><p>  双亲委派模式的原理也十分简单，类加载器收到类加载请求，会委托给父类加载器去执行，父类加载器还存在其父类加载器，则进一步向上委托，依次递归，直到顶层类加载器，如果顶层类加载器加载到该类，就成功返回 class 对象，否则委托给下级类加载器去执行，依次递归（此处的父子关系并非通常所说的继承关系，而是采用组合关系来实现）。</p><h3 id="双亲委派机制好处" tabindex="-1">双亲委派机制好处 <a class="header-anchor" href="#双亲委派机制好处" aria-label="Permalink to &quot;双亲委派机制好处&quot;">​</a></h3><p>  Jvm 中类的唯一性是由类本身和加载这个类的类加载器决定的，简单的说，如果有个 a 类，如果被两个不同的类加载器加载，那么他们必不相等。你看到这里会不会想到所有类的父类都是 Object 是怎么实现的了吗？是因为无论哪一个类加载器加载 Object 类，都会交给最顶层的启动类加载器去加载，这样就保证了 Object 类在 Jvm 中是唯一的。</p>',23);function V(a,k,J,L,j,A){const o=i,l=c("ClientOnly");return s(),d("div",null,[P,h(l,null,{default:p(()=>{var e,t;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((t=a.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(s(),u(o,{key:0,article:a.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),x])}const E=n(v,[["render",V]]);export{y as __pageData,E as default};
