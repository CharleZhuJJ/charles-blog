import{_ as r}from"./chunks/ArticleMetadata.4c626a83.js";import{_ as i,D as c,o as l,c as u,G as y,B as d,z as a,a as A,R as o,A as h,C as m}from"./chunks/framework.ef995079.js";const P=JSON.parse('{"title":"Spring注解","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"md/Java/Spring/SpringAnnotations.md","filePath":"md/Java/Spring/SpringAnnotations.md","lastUpdated":1688441607000}'),D={name:"md/Java/Spring/SpringAnnotations.md"},C=a("h1",{id:"spring注解",tabindex:"-1"},[A("Spring注解 "),a("a",{class:"header-anchor",href:"#spring注解","aria-label":'Permalink to "Spring注解"'},"​")],-1),b=o('<h2 id="元注解" tabindex="-1">元注解 <a class="header-anchor" href="#元注解" aria-label="Permalink to &quot;元注解&quot;">​</a></h2><p> 元注解的作用就是负责注解其它注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其它annotation类型作说明。</p><p> 这些类型和它们所支持的类在 java.lang.annotation包可以找到 @Target 、@Retention、@Documented、@Inherited</p><ul><li>@Target：用于描述注解的使用范围，即：被描述的注解可以在什么地方使用</li><li>@Retention：表示需要什么保存该注释信息，用于描述注解的生命周期； <ul><li>级别范围：Source &lt; Class &lt; Runtime</li></ul></li><li>@Document：说明该注解被包含在java doc中</li><li>@Inherited：说明子类可以集成父类中的注解</li></ul><h2 id="自定义注解" tabindex="-1">自定义注解 <a class="header-anchor" href="#自定义注解" aria-label="Permalink to &quot;自定义注解&quot;">​</a></h2><p>  使用 @interface自定义注解时，自动继承了 java.lang.annotation.Annotation接口</p>',6),g=a("ul",null,[a("li",{定义内容:""},"@interface 用来声明一个注解，格式：public @interface 注解名"),a("li",null,"其中的每个方法实际上是申明了一个配置参数"),a("li",null,"方法的名称就是参数的名称"),a("li",null,"返回值类型就是参数的类型（返回值只能是基本数据类型，Class，String，enum）"),a("li",null,"通过default来申明参数的默认值"),a("li",null,"如果只有一个参数成员，一般参数名为 value"),a("li",null,"注解元素必须要有值，我们定义元素时，经常使用空字符串或者0作为默认值")],-1),B=o(`<h2 id="component" tabindex="-1">@Component <a class="header-anchor" href="#component" aria-label="Permalink to &quot;@Component&quot;">​</a></h2><ul><li>作用：用于把当前类对象存入spring容器中</li><li>属性：value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</li></ul><h2 id="configuration" tabindex="-1">@Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;@Configuration&quot;">​</a></h2><ul><li>用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。</li><li>获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。</li><li>当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</li></ul><h2 id="componentscan" tabindex="-1">@ComponentScan <a class="header-anchor" href="#componentscan" aria-label="Permalink to &quot;@ComponentScan&quot;">​</a></h2><p>  用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的：&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;是一样的。</p><ul><li>自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</li><li>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</li></ul><p>  注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages</p><h2 id="bean" tabindex="-1">@Bean <a class="header-anchor" href="#bean" aria-label="Permalink to &quot;@Bean&quot;">​</a></h2><p>  该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。</p><ul><li>属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">Target</span><span style="color:#ADBAC7;">({ElementType.METHOD, ElementType.ANNOTATION_TYPE})</span></span>
<span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">Retention</span><span style="color:#ADBAC7;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="color:#ADBAC7;">@</span><span style="color:#F47067;">Documented</span></span>
<span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> @</span><span style="color:#F47067;">interface</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">Bean</span><span style="color:#ADBAC7;"> {</span></span>
<span class="line"><span style="color:#ADBAC7;">    @</span><span style="color:#F47067;">AliasFor</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;name&quot;</span><span style="color:#ADBAC7;">)</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">String</span><span style="color:#ADBAC7;">[] </span><span style="color:#DCBDFB;">value</span><span style="color:#ADBAC7;">() </span><span style="color:#F47067;">default</span><span style="color:#ADBAC7;"> {};</span></span>
<span class="line"><span style="color:#ADBAC7;">    @</span><span style="color:#F47067;">AliasFor</span><span style="color:#ADBAC7;">(</span><span style="color:#96D0FF;">&quot;value&quot;</span><span style="color:#ADBAC7;">)</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#F47067;">String</span><span style="color:#ADBAC7;">[] </span><span style="color:#DCBDFB;">name</span><span style="color:#ADBAC7;">() </span><span style="color:#F47067;">default</span><span style="color:#ADBAC7;"> {};</span></span>
<span class="line"><span style="color:#ADBAC7;">    Autowire </span><span style="color:#DCBDFB;">autowire</span><span style="color:#ADBAC7;">() </span><span style="color:#F47067;">default</span><span style="color:#ADBAC7;"> Autowire.NO;</span></span>
<span class="line"><span style="color:#ADBAC7;">    String </span><span style="color:#DCBDFB;">initMethod</span><span style="color:#ADBAC7;">() </span><span style="color:#F47067;">default</span><span style="color:#ADBAC7;"> </span><span style="color:#96D0FF;">&quot;&quot;</span><span style="color:#ADBAC7;">; </span><span style="color:#768390;">// bean的初始化之前的执行方法，该参数一般不怎么用，因为完全可以在代码中实现；</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#768390;">// 默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法。</span></span>
<span class="line"><span style="color:#ADBAC7;">    </span><span style="color:#768390;">// 如果你不想执行该方法，则添加@Bean(destroyMethod=&quot;&quot;)来防止出发销毁方法；</span></span>
<span class="line"><span style="color:#ADBAC7;">    String </span><span style="color:#DCBDFB;">destroyMethod</span><span style="color:#ADBAC7;">() </span><span style="color:#F47067;">default</span><span style="color:#ADBAC7;"> AbstractBeanDefinition.INFER_METHOD;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Target</span><span style="color:#24292E;">({ElementType.METHOD, ElementType.ANNOTATION_TYPE})</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Retention</span><span style="color:#24292E;">(RetentionPolicy.RUNTIME)</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Documented</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Bean</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">AliasFor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">AliasFor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;value&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#24292E;">    Autowire </span><span style="color:#6F42C1;">autowire</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> Autowire.NO;</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">initMethod</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// bean的初始化之前的执行方法，该参数一般不怎么用，因为完全可以在代码中实现；</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 默认使用javaConfig配置的bean，如果存在close或者shutdown方法，则在bean销毁时会自动执行该方法。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果你不想执行该方法，则添加@Bean(destroyMethod=&quot;&quot;)来防止出发销毁方法；</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">destroyMethod</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> AbstractBeanDefinition.INFER_METHOD;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="lazy" tabindex="-1">@Lazy <a class="header-anchor" href="#lazy" aria-label="Permalink to &quot;@Lazy&quot;">​</a></h2><ul><li>表明一个bean 是否延迟加载，可以作用在方法上，表示这个方法被延迟加载；可以作用在@Component (或者由@Component 作为原注解) 注释的类上，表明这个类中所有的bean 都被延迟加载。</li><li>如果没有@Lazy注释，或者@Lazy 被设置为false，那么该bean 就会急切渴望被加载；</li><li>@Lazy 可以作用在@Autowired和@Inject注释的属性上，它将为该字段创建一个惰性代理，作为使用ObjectFactory或Provider的默认方法。</li></ul><h2 id="propertysource" tabindex="-1">@PropertySource <a class="header-anchor" href="#propertysource" aria-label="Permalink to &quot;@PropertySource&quot;">​</a></h2><ul><li>用于加载.properties文件中的配置。</li><li>例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定properties配置文件的位置。</li><li>属性：value[]：用于指定 properties 文件位置。（！！！！如果是在类路径下，需要写上 classpath: ！！！！）</li></ul><h2 id="import" tabindex="-1">@Import <a class="header-anchor" href="#import" aria-label="Permalink to &quot;@Import&quot;">​</a></h2><ul><li>用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。</li><li>属性：value[]：用于指定其他配置类的字节码。</li></ul><h2 id="resource和-autowired" tabindex="-1">@Resource和@Autowired <a class="header-anchor" href="#resource和-autowired" aria-label="Permalink to &quot;@Resource和@Autowired&quot;">​</a></h2><ul><li>@Resource和@Autowired都是做bean的注入时使用</li><li>@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</li><li>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</li></ul><h3 id="autowired" tabindex="-1">@Autowired <a class="header-anchor" href="#autowired" aria-label="Permalink to &quot;@Autowired&quot;">​</a></h3><ul><li>@Autowired注解是按照类型(byType)装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，设置它的required属性为false。</li><li>如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</li><li>@Autowired可用于：构造函数、成员变量、Setter方法</li></ul><h3 id="resource" tabindex="-1">@Resource <a class="header-anchor" href="#resource" aria-label="Permalink to &quot;@Resource&quot;">​</a></h3><ul><li>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</li><li>@Resource有两个重要的属性：name和type，而Spring将@Resource注解name属性解析为bean的名字，而type属性则解析为bean的类型。</li><li>所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li></ul><h2 id="required" tabindex="-1">@Required <a class="header-anchor" href="#required" aria-label="Permalink to &quot;@Required&quot;">​</a></h2><p>  这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。</p>`,26);function f(n,E,_,q,F,S){const t=r,p=c("ClientOnly");return l(),u("div",null,[C,y(p,null,{default:d(()=>{var s,e;return[(((s=n.$frontmatter)==null?void 0:s.aside)??!0)&&(((e=n.$frontmatter)==null?void 0:e.showArticleMetadata)??!0)?(l(),h(t,{key:0,article:n.$frontmatter},null,8,["article"])):m("",!0)]}),_:1}),b,g,B])}const R=i(D,[["render",f]]);export{P as __pageData,R as default};
