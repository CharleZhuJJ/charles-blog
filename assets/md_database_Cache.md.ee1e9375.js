import{_ as n}from"./chunks/ArticleMetadata.8b6b367a.js";import{_ as h,H as d,o as t,c as s,J as c,E as p,C as i,a as u,V as _,D as m,G as f}from"./chunks/framework.981adca9.js";const $=JSON.parse('{"title":"缓存","description":"","frontmatter":{"title":"缓存","author":"Charles Chu","date":"2021/12/15","isOriginal":true},"headers":[],"relativePath":"md/database/Cache.md","filePath":"md/database/Cache.md","lastUpdated":1691825438000}'),b={name:"md/database/Cache.md"},q=i("h1",{id:"缓存",tabindex:"-1"},[u("缓存 "),i("a",{class:"header-anchor",href:"#缓存","aria-label":'Permalink to "缓存"'},"​")],-1),k=_('<h2 id="哪类数据适合缓存" tabindex="-1">哪类数据适合缓存 <a class="header-anchor" href="#哪类数据适合缓存" aria-label="Permalink to &quot;哪类数据适合缓存&quot;">​</a></h2><p>  缓存量大但又不常变化的数据，比如详情，评论等。</p><p>  对于那些经常变化的数据，其实并不适合缓存，一方面会增加系统的复杂性（缓存的更新，缓存脏数据），另一方面也给系统带来一定的不稳定性（缓存系统的维护）。</p><p>  但一些极端情况下，你需要将一些会变动的数据进行缓存，比如想要页面显示准实时的库存数，或者其他一些特殊业务场景。这时候你需要保证缓存不能（一直）有脏数据，这就需要再深入讨论一下。</p><h2 id="缓存的利与弊" tabindex="-1">缓存的利与弊 <a class="header-anchor" href="#缓存的利与弊" aria-label="Permalink to &quot;缓存的利与弊&quot;">​</a></h2><p>  我们到底该不该上缓存的，这其实也是个trade-off（权衡）的问题。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>能够缩短服务的响应时间，给用户带来更好的体验。</li><li>能够增大系统的吞吐量，依然能够提升用户体验。</li><li>减轻数据库的压力，防止高峰期数据库被压垮，导致整个线上服务BOOM！</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>缓存有多种选型，是内存缓存，memcached还是redis，你是否都熟悉，如果不熟悉，无疑增加了维护的难度（本来是个纯洁的数据库系统）。</li><li>缓存系统也要考虑分布式，比如redis的分布式缓存还会有很多坑，无疑增加了系统的复杂性。</li><li>在特殊场景下，如果对缓存的准确性有非常高的要求，就必须考虑缓存和数据库的一致性问题。</li></ul><h2 id="缓存与数据库一致性" tabindex="-1">缓存与数据库一致性 <a class="header-anchor" href="#缓存与数据库一致性" aria-label="Permalink to &quot;缓存与数据库一致性&quot;">​</a></h2><h3 id="不更新缓存-而是删除缓存" tabindex="-1">不更新缓存，而是删除缓存 <a class="header-anchor" href="#不更新缓存-而是删除缓存" aria-label="Permalink to &quot;不更新缓存，而是删除缓存&quot;">​</a></h3><p>  大部分观点认为，做缓存不应该是去更新缓存，而是应该删除缓存，然后由下个请求去去缓存，发现不存在后再读取数据库，写入缓存。</p><p>  业务场景角度有如下两点：</p><ol><li>如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</li><li>如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</li></ol><h3 id="先操作缓存-还是先操作数据库" tabindex="-1">先操作缓存，还是先操作数据库 <a class="header-anchor" href="#先操作缓存-还是先操作数据库" aria-label="Permalink to &quot;先操作缓存，还是先操作数据库&quot;">​</a></h3><h4 id="_1、先删缓存-再更新数据库" tabindex="-1">1、先删缓存，再更新数据库 <a class="header-anchor" href="#_1、先删缓存-再更新数据库" aria-label="Permalink to &quot;1、先删缓存，再更新数据库&quot;">​</a></h4><p>  该方案会导致请求数据不一致</p><p>  同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p><ol><li>请求A进行写操作，删除缓存</li><li>请求B查询发现缓存不存在</li><li>请求B去数据库查询得到旧值</li><li>请求B将旧值写入缓存</li><li>请求A将新值写入数据库</li></ol><p>  上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><h4 id="_2、先更新数据库-再删缓存" tabindex="-1">2、先更新数据库，再删缓存 <a class="header-anchor" href="#_2、先更新数据库-再删缓存" aria-label="Permalink to &quot;2、先更新数据库，再删缓存&quot;">​</a></h4><p>  依然会有问题，不过，问题出现的可能性会变得比较低！</p><p>  假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p><ol><li>缓存刚好失效</li><li>请求A查询数据库，得一个旧值</li><li>请求B将新值写入数据库</li><li>请求B删除缓存</li><li>请求A将查到的旧值写入缓存</li></ol><p>  如果发生上述情况，确实是会发生脏数据。</p><p>  然而，发生这种情况的概率比较低。发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更长，这一情形很难出现。</p><p>  所以，如果你想实现基础的缓存数据库双写一致的逻辑，那么在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!</p><h3 id="缓存延时双删" tabindex="-1">缓存延时双删 <a class="header-anchor" href="#缓存延时双删" aria-label="Permalink to &quot;缓存延时双删&quot;">​</a></h3><p>  为了到达最终一致性的解决思路，主要是针对上面两种双写策略（先删缓存，再更新数据库/先更新数据库，再删缓存）导致的脏数据问题，进行相应的处理，来保证最终一致性。</p><p>  延时双删</p><ol><li>先淘汰缓存</li><li>再写数据库（这两步和原来一样）</li><li>休眠1秒，再次淘汰缓存</li></ol><p>  这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p><p>  休眠时间的确认：针对上面的情形，应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>  总结：缓存做不到绝对一致性，但可以做到最终一致性。</p>',35);function P(a,C,x,B,A,V){const r=n,o=d("ClientOnly");return t(),s("div",null,[q,c(o,null,{default:p(()=>{var e,l;return[(((e=a.$frontmatter)==null?void 0:e.aside)??!0)&&(((l=a.$frontmatter)==null?void 0:l.showArticleMetadata)??!0)?(t(),m(r,{key:0,article:a.$frontmatter},null,8,["article"])):f("",!0)]}),_:1}),k])}const O=h(b,[["render",P]]);export{$ as __pageData,O as default};
