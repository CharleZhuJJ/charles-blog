import{_ as t}from"./chunks/ArticleMetadata.9dfa2fc3.js";import{_ as r,D as c,o as l,c as i,G as y,B as d,z as e,a as A,R as h,A as C,C as D}from"./chunks/framework.e2a84f7d.js";const u="/assets/LongQuote.c5a2188d.png",V=JSON.parse('{"title":"内存泄漏","description":"","frontmatter":{},"headers":[],"relativePath":"md/Java/javaUnderlayer/MemoryLeak.md","filePath":"md/Java/javaUnderlayer/MemoryLeak.md","lastUpdated":1688441607000}'),v={name:"md/Java/javaUnderlayer/MemoryLeak.md"},B=e("h1",{id:"内存泄漏",tabindex:"-1"},[A("内存泄漏 "),e("a",{class:"header-anchor",href:"#内存泄漏","aria-label":'Permalink to "内存泄漏"'},"​")],-1),m=h('<h2 id="什么是内存泄漏" tabindex="-1">什么是内存泄漏？ <a class="header-anchor" href="#什么是内存泄漏" aria-label="Permalink to &quot;什么是内存泄漏？&quot;">​</a></h2><p>  内存泄漏：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</p><p>  在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，</p><ul><li>首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；</li><li>其次，这些对象是无用的，即程序以后不会再使用这些对象。</li></ul><p>  如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><h2 id="java中的内存泄漏" tabindex="-1">Java中的内存泄漏 <a class="header-anchor" href="#java中的内存泄漏" aria-label="Permalink to &quot;Java中的内存泄漏&quot;">​</a></h2><h3 id="java内存回收机制" tabindex="-1">Java内存回收机制 <a class="header-anchor" href="#java内存回收机制" aria-label="Permalink to &quot;Java内存回收机制&quot;">​</a></h3><p>  不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。</p><p>  GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。</p><p>  在Java语言中，判断一个内存空间是否符合垃圾收集的标准有两个：一个是给对象赋予了空值null，以下再没有调用过另一个是给对象赋予了新值，这样重新分配了内存空间。</p><h3 id="java内存泄漏引起的原因" tabindex="-1">Java内存泄漏引起的原因 <a class="header-anchor" href="#java内存泄漏引起的原因" aria-label="Permalink to &quot;Java内存泄漏引起的原因&quot;">​</a></h3><p>  内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。</p><p>  Java内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。</p><p>  如：A对象引用B对象，A对象的生命周期（t1-t4）比B对象的生命周期（t2-t3）长的多。当B对象没有被应用程序使用之后，A对象仍然在引用着B对象。这样，垃圾回收器就没办法将B对象从内存中移除，从而导致内存问题。因为如果A引用更多这样的对象，那将有更多的未被引用对象存在，并消耗内存空间。B对象也可能会持有许多其他的对象，那这些对象同样也不会被垃圾回收器回收。所有这些没在使用的对象将持续的消耗之前分配的内存空间。 <img src="'+u+`" alt="LongQuote"></p><h4 id="内存泄漏例子" tabindex="-1">内存泄漏例子 <a class="header-anchor" href="#内存泄漏例子" aria-label="Permalink to &quot;内存泄漏例子&quot;">​</a></h4><h5 id="_1-静态集合类引起内存泄漏" tabindex="-1">1.静态集合类引起内存泄漏 <a class="header-anchor" href="#_1-静态集合类引起内存泄漏" aria-label="Permalink to &quot;1.静态集合类引起内存泄漏&quot;">​</a></h5><p>  像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#ADBAC7;">Static</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">Vector</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">v</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Vector</span><span style="color:#ADBAC7;">(</span><span style="color:#6CB6FF;">10</span><span style="color:#ADBAC7;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F47067;">for</span><span style="color:#ADBAC7;"> (</span><span style="color:#F47067;">int</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">i</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">0</span><span style="color:#ADBAC7;">; i </span><span style="color:#F47067;">&lt;</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">100</span><span style="color:#ADBAC7;">; i</span><span style="color:#F47067;">++</span><span style="color:#ADBAC7;">) {</span></span>
<span class="line"><span style="color:#ADBAC7;">    Object</span><span style="color:#F69D50;"> </span><span style="color:#ADBAC7;">o</span><span style="color:#F69D50;"> </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">new</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">Object</span><span style="color:#ADBAC7;">();</span></span>
<span class="line"><span style="color:#ADBAC7;">    v.</span><span style="color:#DCBDFB;">add</span><span style="color:#ADBAC7;">(o);</span></span>
<span class="line"><span style="color:#ADBAC7;">    o </span><span style="color:#F47067;">=</span><span style="color:#ADBAC7;"> </span><span style="color:#6CB6FF;">null</span><span style="color:#ADBAC7;">;</span></span>
<span class="line"><span style="color:#ADBAC7;">}</span></span>
<span class="line"><span style="color:#768390;">// 循环申请Object 对象，并将所申请的对象放入一个Vector 中，</span></span>
<span class="line"><span style="color:#768390;">// 如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。</span></span>
<span class="line"><span style="color:#768390;">// 因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Static Vector v </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Vector</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    Object o </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    v.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(o);</span></span>
<span class="line"><span style="color:#24292E;">    o </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 循环申请Object 对象，并将所申请的对象放入一个Vector 中，</span></span>
<span class="line"><span style="color:#6A737D;">// 如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。</span></span>
<span class="line"><span style="color:#6A737D;">// 因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。</span></span></code></pre></div><h5 id="_2-监听器" tabindex="-1">2.监听器 <a class="header-anchor" href="#_2-监听器" aria-label="Permalink to &quot;2.监听器&quot;">​</a></h5><p>  在 java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener() 等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。</p><h5 id="_3-各种连接" tabindex="-1">3.各种连接 <a class="header-anchor" href="#_3-各种连接" aria-label="Permalink to &quot;3.各种连接&quot;">​</a></h5><p>  比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close() 方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。</p><p>  但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try 里面去的连接，在finally里面释放连接。</p><h5 id="_4-内部类和外部模块的引用" tabindex="-1">4.内部类和外部模块的引用 <a class="header-anchor" href="#_4-内部类和外部模块的引用" aria-label="Permalink to &quot;4.内部类和外部模块的引用&quot;">​</a></h5><p>  内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark-dimmed vp-code-dark"><code><span class="line"><span style="color:#F47067;">public</span><span style="color:#ADBAC7;"> </span><span style="color:#F47067;">void</span><span style="color:#ADBAC7;"> </span><span style="color:#DCBDFB;">registerMsg</span><span style="color:#ADBAC7;">(Object b);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">registerMsg</span><span style="color:#24292E;">(Object b);</span></span></code></pre></div>`,26);function _(a,b,F,f,k,E){const o=t,p=c("ClientOnly");return l(),i("div",null,[B,y(p,null,{default:d(()=>{var s,n;return[(((s=a.$frontmatter)==null?void 0:s.aside)??!0)&&(((n=a.$frontmatter)==null?void 0:n.showArticleMetadata)??!0)?(l(),C(o,{key:0,article:a.$frontmatter},null,8,["article"])):D("",!0)]}),_:1}),m])}const q=r(v,[["render",_]]);export{V as __pageData,q as default};
