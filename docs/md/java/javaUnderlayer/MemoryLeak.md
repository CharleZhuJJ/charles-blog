---
title: 内存泄漏
author: Charles Chu
date: 2021/06/17
isOriginal: true
---

# 内存泄漏

## 什么是内存泄漏？

&emsp; 内存泄漏：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。

&emsp; 在 Java 中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，

- 首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 其次，这些对象是无用的，即程序以后不会再使用这些对象。

&emsp; 如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。

## Java 中的内存泄漏

### Java 内存回收机制

&emsp; 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成的。

&emsp; GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java 会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。

&emsp; 在 Java 语言中，判断一个内存空间是否符合垃圾收集的标准有两个：一个是给对象赋予了空值 null，以下再没有调用过另一个是给对象赋予了新值，这样重新分配了内存空间。

### Java 内存泄漏引起的原因

&emsp; 内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你 Out of memory。

&emsp; Java 内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。

&emsp; 如：A 对象引用 B 对象，A 对象的生命周期（t1-t4）比 B 对象的生命周期（t2-t3）长的多。当 B 对象没有被应用程序使用之后，A 对象仍然在引用着 B 对象。这样，垃圾回收器就没办法将 B 对象从内存中移除，从而导致内存问题。因为如果 A 引用更多这样的对象，那将有更多的未被引用对象存在，并消耗内存空间。B 对象也可能会持有许多其他的对象，那这些对象同样也不会被垃圾回收器回收。所有这些没在使用的对象将持续的消耗之前分配的内存空间。
![LongQuote](/public/java/javaUnderlayer/memoryLeak/LongQuote.png)

#### 内存泄漏例子

##### 1.静态集合类引起内存泄漏

&emsp; 像 HashMap、Vector 等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等引用着。

```java
Static Vector v = new Vector(10);

for (int i = 0; i < 100; i++) {
    Object o = new Object();
    v.add(o);
    o = null;
}
// 循环申请Object 对象，并将所申请的对象放入一个Vector 中，
// 如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。
// 因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。
```

##### 2.监听器

&emsp; 在 java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如 addXXXListener() 等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。

##### 3.各种连接

&emsp; 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和 io 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的。对于 Resultset 和 Statement 对象可以不进行显式回收，但 Connection 一定要显式回收，因为 Connection 在任何时候都无法自动回收，而 Connection 一旦回收，Resultset 和 Statement 对象就会立即为 NULL。

&emsp; 但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭 Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的 Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在 try 里面去的连接，在 finally 里面释放连接。

##### 4.内部类和外部模块的引用

&emsp; 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员 A 负责 A 模块，调用了 B 模块的一个方法如：

```java
public void registerMsg(Object b);
```
