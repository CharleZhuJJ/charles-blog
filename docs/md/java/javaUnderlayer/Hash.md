# 哈希（Hash）

&emsp; 哈希表的出现是为了解决链表访问不快速的弱点

&emsp; 哈希表中有一个哈希函数(散列函数)。即构建一个确定的映射，它能把关键字映射到一个唯一的存储位置。这种映射应该是我们可以进行计算的。

&emsp; 已知关键字，我们应该能算出其地址；反之，已知地址，我们可以检索到对应的关键字。一旦建立起这种关系，那么给定关键字，我就能直接利用这个映射(即所谓的哈希函数)直接算出其地址并寻址。这可大大缩减确定关键字存储位置所花的时间。

## HashSet 和 HashMap
&emsp; HashSet是通过HashMap来实现的，HashMap的输入参数有Key、Value两个组成，在实现HashSet的时候，保持HashMap的Value为常量，相当于在HashMap中只对Key对象进行处理。

&emsp; HashMap的底层是一个数组结构，数组中的每一项对应了一个链表，这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。

&emsp; HashSet实现了Set接口，其内部不允许出现重复的值，如果我们将一个对象存入HashSet，必须重写equals()和hashCode()方法，这样才能确保集合中不存在同一个元素。HashSet的内部是无序的，因此不能使用 hashset.get(index) 来获取元素。

&emsp; HashMap实现了Map接口，其内容是键值对的映射（key->value），不允许出现相同的键（key）。在查询的时候会根据给出的键来查询对应的值。

### HashMap存储对象的过程
- 对HashMap的Key调用hashCode()方法，返回int值，即对应的hashCode；
- 把此hashCode作为哈希表的索引，查找哈希表相应位置，若当前位置内容为NULL，则把HashMap的Key、Value包装成Entry数组，放入当前位置；
- 若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；
- 若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；

### HashSet存储对象的过程
- 往HashSet添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，
- 然后通过元素的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置，存储时会出现两种情况：
    - 情况1：如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。
    - 情况2：如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不允许添加，如果equals方法返回的是false，那么该元素允许添加。


## 哈希表的扩容

&emsp; 哈希表容量的大小在一开始是不确定的。如果哈希表存储的元素太多（如超过容量的30%），我们应该将哈希表容量扩大一倍，并将所有的哈希值重新安排。